
import processing.video.*;

Capture cam;
//convolution kernel
PImage lastImg;
PImage currentImg;
color lastColor;
color currentColor;
float lRed;
float lGreen;
float lBlue;
int effect = 0;

//static processing types
static final int BWGHOST = 0;
static final int CHALK = 1;
static final int BLACKLIGHT = 2;
static final int CONVOLVEDBLACKLIGHT = 3;
static final int MORECOLOR = 4;

//edge
/*
float[][] kernel = {{ -1, -1, -1},
                    { -1,  8, -1},
                    { -1, -1, -1}};
         */

/*
float[][] kernel = {{ 0, -1, 0},
                    { -1,  5, -1},
                    { 0, -1, 0}};

                    {{ -1, -2, -1},
                    { 0, 0, 0},
                    { 1, 2, 1}};

kernel
         */

//blur

//edge- like chalk on black. very cool. Can colorize, too.

float[][] kernel = {{ -1, -1, -1},
                    { -1,  8, -1},
                    { -1, -1, -1}};
//big blur
/*
float[][] kernel = {{ 1, 4, 6, 4, 1},
                    { 4, 16, 24, 16, 4},
                    { 6, 24, 36, 24, 6},
                    { 4, 16, 24, 16, 4},
                    { 1, 4, 6, 4, 1}};
        */

int stride = 1;

void setup() {
  size(1280, 720);

  String[] cameras = Capture.list();

  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
  } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(cameras[i]);
    }

    // The camera can be initialized directly using an element from the array returned by list():
    cam = new Capture(this, cameras[0]);
    cam.start();
  }

  //initialize last image
  lastImg = createImage(cam.width, cam.height, RGB);
}

void draw() {


  if (cam.available() == true) {
    cam.read();
  }


  // The following does the same, and is faster when just drawing the image
  // without any additional resizing, transformations, or tint.
  //set(0, 0, cam);
  image(cam, 0, 0); // Displays the image from point (0,0)
  cam.loadPixels();
  // Create an opaque image of the same size as the original
  PImage edgeImg = createImage(cam.width, cam.height, RGB);

    //save a copy of the image for adding memory to processing. don't work with convoluted image.
  currentImg = cam.copy();


  // Loop through every pixel in the image.
  for (int y = 1; y < cam.height-1; y+=stride) { // Skip top and bottom edges



    for (int x = 1; x < cam.width-1; x+=stride) { // Skip left and right edges
      float sum = 0; // Kernel sum for this pixel
      float[] colorSum = {0,0,0};

      for (int ky = -1; ky <= 1; ky++) {
        for (int kx = -1; kx <= 1; kx++) {
          // Calculate the adjacent pixel for this kernel point
          int pos = (y + ky)*cam.width + (x + kx);
          float r = red(cam.pixels[pos]);
          float g = green(cam.pixels[pos]);
          float b = blue(cam.pixels[pos]);
          // Multiply adjacent pixels based on the kernel values

          sum += (kernel[ky+1][kx+1] * (r + g + b)/3f);
          colorSum[0] += kernel[ky+1][kx+1] * r;
          colorSum[1] += kernel[ky+1][kx+1] * g;
          colorSum[2] += kernel[ky+1][kx+1] * b;
        }
      }

      if (lastImg.pixels.length > 0)
      {
        //put pixels into array
        lastImg.loadPixels();
        //read out the pixel color for the last image and use to alter the next image
        lastColor = lastImg.pixels[y*cam.width + x];
        currentColor = currentImg.pixels[y*cam.width + x];
      }

      //load value directly into the pixel array
      edgeImg.pixels[y*cam.width + x] = fxColor(sum, colorSum, lastColor, currentColor, effect);
    }
  }
  // State that there are changes to edgeImg.pixels[]
  edgeImg.updatePixels();
  image(edgeImg, 0, 0); // Draw the new image

lastImg = cam.copy();
}

void keyPressed() {
  //go to next processing effect
  effect++;
  if (effect > MORECOLOR)
  {
    effect = BWGHOST;
  }
}



//apply memory
/*
This function creates a ghostly image (black and white) . Slowed and delyaed video with trails.
*/
float applyMemory(float input, float history)
{
   float newColor = input + history;

   if (newColor > 255)
   {
     newColor = 255;
   }

  return newColor;
}

color fxColor(float input, float[] colorArray, color lastColor, color currentColor, int type)
{
    color newColor = color(100,100,100);
    //break into rgb values - float redValue = red(c);
    lRed = red(lastColor);
    lGreen = green(lastColor);
    lBlue = blue(lastColor);

    float red = 0, green = 0, blue = 0;

    //println(input + lRed);

   //switch on type and select various little algorithms for pixel color processing
   switch (type) {

     case BWGHOST:
       red = bound(input + lRed);
       green = bound(input + lGreen);
       blue = bound(input + lBlue);
       newColor = color(red, green, blue);
       break;
     case CHALK:
       newColor = getChalk(input, lRed, lGreen, lBlue);
       break;
    case BLACKLIGHT:
       newColor = getBlacklight(currentColor, lRed, lGreen, lBlue);
       break;
    case CONVOLVEDBLACKLIGHT:
       newColor = getConvolvedBlacklight(colorArray, currentColor, lRed, lGreen, lBlue);
       break;
     case MORECOLOR:
       newColor = getBlacklightMoreColor(currentColor, lRed, lGreen, lBlue);
       break;

   }


  return newColor;
}

float bound(float input)
{
       if (input > 255)
       {
         input = 255;
       }

  return input;
}


color getChalk(float input, float r, float g, float b)
{
  color chalk = 0;
  float red = 0, green = 0, blue = 0;


  red = input - 10f * Math.abs(input - r)/10f;
  green = input - 10f * Math.abs(input - g)/10f;
  blue = input - 10f * Math.abs(input - b)/10f;

  chalk =  color(red, green, blue);
  return chalk;
}


color getBlacklight(color current, float r, float g, float b)
{
  float red = 0, green = 0, blue = 0;
  red = r - red(current);
  green = g - green(current);
  blue = b - blue(current);

  return color(red, green, blue);
}

color getBlacklightMoreColor(color current, float r, float g, float b)
{
  float red = 0, green = 0, blue = 0;

  float redScale = (float)Math.random(), greenScale = (float)Math.random(), blueScale = (float)Math.random();

  //looks cool
  red = r - red(current) + redScale * 20;
  green = g - green(current) + greenScale * 10;
  blue = b - blue(current) + blueScale * 7;

  return color(red, green, blue);
}

color getConvolvedBlacklight(float[] input, color current, float r, float g, float b)
{
  float redScale = (float)Math.random(), greenScale = (float)Math.random(), blueScale = (float)Math.random();
  float red = 0, green = 0, blue = 0;
  red = (input[0] + red(current))/2 - r + redScale * 20;
  green = (input[1] + green(current))/2 - g + greenScale * 20;
  blue = (input[2] + blue(current))/2 - b + blueScale * 20;

  return color(red, green, blue);
}
